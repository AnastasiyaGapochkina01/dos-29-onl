# Пользователи и права доступа
1) Создать директорию `/var/www/server-app`; в ней файлы `readme.md` и `app.log`; директорию `uploads`
2) Создать:
- группу `ftpusers`
- группу `admins`
- группу `auditors`
- пользователя `logger` с домашней директорией `/opt/logger` и без возможности входа в систему
3) Разрешить с помощью ACL:
- пользователю `www-data` чтение всех файлов
- группе `ftpusers` запись в `uploads`
- группе `admins` полный доступ 
- пользователю `logger` полный доступ только к файлу `app.log`
- группе `auditors` чтение файла `app.log`
4) Настроить систему так, чтобы новые файлы создавались с правами `rw-r-----`, а директории - `rwxr-x---`
> [!IMPORTANT]  
> не забудьте восстановить исходное состояние системы после проверки

5) Разрешить пользователю `logger` вход в систему; переключиться на него с помощью `su`, сохранив текущее окружение и создать файл `/tmp/logger-envs` и вывести в него переменные окружения. Выйти и переключиться еще раз с `-`; сравнить вывод `env` и содержимое файла `/tmp/logger-envs`
6) Без переключения пользователя создать от имени `logger` директорию `/tmp/logger-dir`

# Анализ производительности
> [!WARNING]   
> будьте осторожны, при выполнении можно неслабо "приложить" машину

1) Определите текущую load average; установить пакет `sysstat`
2) Запустить стресс-тест с помощью утилиты `stress-ng`:
- `stress-ng --cpu 4 --timeout 600`
- `stress-ng --vm 2 --vm-bytes 2G --timeout 300 &`
- `stress-ng --vm 1 --vm-bytes 1G --timeout 300 -s 1`
3) Понаблюдать за тем что показывают утилиты
- `dstat -cglmns --top-cpu --top-mem --top-io`
- `mpstat -P ALL`
4) Запустить `dd if=/dev/zero of=/tmp/testfile bs=1M count=500` и параллельно с помощью iostat найти
- устройство с максимальной нагрузкой
- %util диска
- await (среднее время ожидания)
5) Самостоятельно изучить такие утилиты как `atop` и `sar`; сгенерировать нагрузку с помощью `stress-ng` и `dd` и проанализировать _постфактум_ с помощью `atop` и `sar` (то есть условно 5 минут понагружали, сняли нагрузку и анализируем что там было)
6) Запустить `openssl speed -seconds 30 2>& 1 > /dev/null &` и с помощью `pidstat` найти
- PID процесса openssl
- % пользовательского (usr) и системного (sys) CPU time
7) Запустить `sleep 5; ls -R /usr` и после ее завершения найти
- время выполнения (real, user, sys)
- максимальное потребление памяти
8) Запустить стресс-тест с помощью утилиты `stress-ng` (параметры подобрать самостоятельно) и вывести с помощью `ps` топ-5 процессов (по очереди) с наибольшим потреблением 
- CPU
- DISK
- MEM
